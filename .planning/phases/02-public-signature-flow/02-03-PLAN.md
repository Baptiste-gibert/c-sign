---
phase: 02-public-signature-flow
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - frontend/src/App.tsx
  - frontend/src/pages/SignPage.tsx
  - frontend/src/pages/SuccessPage.tsx
  - frontend/src/components/ParticipantForm.tsx
  - frontend/src/components/SignatureCanvas.tsx
  - frontend/src/lib/schemas.ts
  - frontend/src/lib/api.ts
  - frontend/src/hooks/use-signature-submission.ts
autonomous: true

must_haves:
  truths:
    - "Participant navigating to /sign/:dayId sees a form with fields: last name, first name, email, city, registration number, beneficiary type"
    - "Participant can draw signature on touch-based canvas"
    - "Participant can clear and redraw signature"
    - "Participant can check right-to-image consent checkbox"
    - "Submitting form creates Participant, uploads signature image to Media, creates Signature record linked to both"
    - "After successful submission, participant sees confirmation page"
    - "Form validates required fields and shows error messages in French"
  artifacts:
    - path: "frontend/src/pages/SignPage.tsx"
      provides: "Main signing page that loads day/session context and renders form"
      min_lines: 50
    - path: "frontend/src/pages/SuccessPage.tsx"
      provides: "Post-submission confirmation page"
      min_lines: 15
    - path: "frontend/src/components/ParticipantForm.tsx"
      provides: "Form with all participant fields + signature canvas + submit button"
      min_lines: 80
    - path: "frontend/src/components/SignatureCanvas.tsx"
      provides: "Touch-enabled signature canvas with clear button and DPI handling"
      min_lines: 40
    - path: "frontend/src/lib/schemas.ts"
      provides: "Zod validation schema for participant form"
      contains: "beneficiaryType"
    - path: "frontend/src/lib/api.ts"
      provides: "API client functions for Payload REST API"
      contains: "fetch"
    - path: "frontend/src/hooks/use-signature-submission.ts"
      provides: "TanStack Query mutation for multi-step submission"
      contains: "useMutation"
  key_links:
    - from: "frontend/src/pages/SignPage.tsx"
      to: "/api/attendance-days"
      via: "fetch on mount to load day info and sessions"
      pattern: "fetch.*api.*(attendance-days|sessions)"
    - from: "frontend/src/hooks/use-signature-submission.ts"
      to: "/api/participants"
      via: "POST to create participant"
      pattern: "fetch.*api/participants.*POST"
    - from: "frontend/src/hooks/use-signature-submission.ts"
      to: "/api/media"
      via: "POST FormData with signature blob"
      pattern: "FormData.*file.*signature"
    - from: "frontend/src/hooks/use-signature-submission.ts"
      to: "/api/signatures"
      via: "POST to create signature record linking participant + media + session"
      pattern: "fetch.*api/signatures.*POST"
    - from: "frontend/src/components/SignatureCanvas.tsx"
      to: "react-signature-canvas"
      via: "ref-based canvas with DPI scaling"
      pattern: "SignatureCanvas|devicePixelRatio"
---

<objective>
Build the complete public signing page: participant form, signature canvas, multi-step API submission, and success confirmation. This is the core user-facing feature of c-sign.

Purpose: This is the primary value proposition -- external participants scan a QR code, fill in their info, draw their signature, and submit. It must work on mobile browsers (iOS Safari, Android Chrome) without login. The form creates a Participant, uploads the signature image to Media, and creates a Signature record linking everything together.

Output: Working signing flow at /sign/:dayId with form validation, touch signature canvas, server submission, and /success confirmation page.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-public-signature-flow/02-RESEARCH.md
@.planning/phases/02-public-signature-flow/02-01-SUMMARY.md
@.planning/phases/02-public-signature-flow/02-02-SUMMARY.md
@backend/src/collections/Participants.ts
@backend/src/collections/Signatures.ts
@backend/src/collections/Sessions.ts
@backend/src/collections/AttendanceDays.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schemas, API client, and submission hook</name>
  <files>
    frontend/src/lib/schemas.ts
    frontend/src/lib/api.ts
    frontend/src/hooks/use-signature-submission.ts
  </files>
  <action>
    **1. Create frontend/src/lib/schemas.ts** -- Zod schema matching Participants collection fields:

    ```typescript
    import { z } from 'zod'

    export const participantSchema = z.object({
      lastName: z.string().min(1, 'Le nom est requis'),
      firstName: z.string().min(1, 'Le prenom est requis'),
      email: z.string().email('Email invalide'),
      city: z.string().min(1, 'La ville est requise'),
      professionalNumber: z.string().optional(),
      beneficiaryType: z.enum(
        ['asv', 'autre', 'eleveur', 'etudiant', 'pharmacien', 'technicien', 'veterinaire'],
        { required_error: 'Le type de beneficiaire est requis' }
      ),
      beneficiaryTypeOther: z.string().optional(),
      consentRightToImage: z.boolean().default(false),
    }).refine(
      (data) => data.beneficiaryType !== 'autre' || (data.beneficiaryTypeOther && data.beneficiaryTypeOther.length > 0),
      { message: 'Veuillez preciser le type de beneficiaire', path: ['beneficiaryTypeOther'] }
    )

    export type ParticipantFormData = z.infer<typeof participantSchema>
    ```

    Match the 7 beneficiary types exactly from the backend Participants collection (alphabetical order): asv, autre, eleveur, etudiant, pharmacien, technicien, veterinaire.

    **2. Create frontend/src/lib/api.ts** -- API client functions for Payload REST API:

    ```typescript
    const API_BASE = '/api'

    export async function fetchAttendanceDay(dayId: string) {
      const res = await fetch(`${API_BASE}/attendance-days/${dayId}?depth=1`)
      if (!res.ok) throw new Error('Journee introuvable')
      return res.json()
    }

    export async function fetchSessionsByDay(dayId: string) {
      const res = await fetch(`${API_BASE}/sessions?where[attendanceDay][equals]=${dayId}&depth=0`)
      if (!res.ok) throw new Error('Erreur chargement sessions')
      return res.json()
    }

    export async function createParticipant(data: Record<string, unknown>) {
      const res = await fetch(`${API_BASE}/participants`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })
      if (!res.ok) {
        const err = await res.json().catch(() => ({}))
        throw new Error(err.errors?.[0]?.message || 'Erreur creation participant')
      }
      return res.json()
    }

    export async function uploadSignatureImage(blob: Blob) {
      const formData = new FormData()
      formData.append('file', blob, `signature-${Date.now()}.png`)
      const res = await fetch(`${API_BASE}/media`, {
        method: 'POST',
        body: formData,
      })
      if (!res.ok) throw new Error('Erreur upload signature')
      return res.json()
    }

    export async function createSignature(data: {
      participant: string
      session: string
      image: string
      rightToImage: boolean
    }) {
      const res = await fetch(`${API_BASE}/signatures`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })
      if (!res.ok) {
        const err = await res.json().catch(() => ({}))
        throw new Error(err.errors?.[0]?.message || 'Erreur creation signature')
      }
      return res.json()
    }
    ```

    IMPORTANT: Signature upload uses a 3-step process (not single FormData with _payload):
    1. POST /api/participants (JSON) -> get participant ID
    2. POST /api/media (FormData with file) -> get media ID
    3. POST /api/signatures (JSON with participant, session, image IDs) -> create signature record

    This avoids the _payload field complexity and works cleanly with Payload's standard REST API.

    **3. Create frontend/src/hooks/use-signature-submission.ts** -- TanStack Query mutation orchestrating the 3-step submission:

    ```typescript
    import { useMutation } from '@tanstack/react-query'
    import { createParticipant, uploadSignatureImage, createSignature } from '@/lib/api'
    import type { ParticipantFormData } from '@/lib/schemas'

    interface SubmissionData {
      formData: ParticipantFormData
      signatureBlob: Blob
      sessionId: string
    }

    export function useSignatureSubmission() {
      return useMutation({
        mutationFn: async ({ formData, signatureBlob, sessionId }: SubmissionData) => {
          // Step 1: Create participant
          const participant = await createParticipant({
            lastName: formData.lastName,
            firstName: formData.firstName,
            email: formData.email,
            city: formData.city,
            professionalNumber: formData.professionalNumber || undefined,
            beneficiaryType: formData.beneficiaryType,
            beneficiaryTypeOther: formData.beneficiaryTypeOther || undefined,
          })

          // Step 2: Upload signature image to Media collection
          const media = await uploadSignatureImage(signatureBlob)

          // Step 3: Create signature record linking participant + session + media
          const signature = await createSignature({
            participant: participant.doc.id,
            session: sessionId,
            image: media.doc.id,
            rightToImage: formData.consentRightToImage,
          })

          return { participant: participant.doc, media: media.doc, signature: signature.doc }
        },
      })
    }
    ```

    The mutation returns all three created documents for potential use in the success page.
  </action>
  <verify>
    Run `cd /workspace/frontend && npx tsc --noEmit` to verify all three files compile.
    Verify schemas.ts exports participantSchema and ParticipantFormData.
    Verify api.ts exports all 5 functions.
    Verify use-signature-submission.ts exports useSignatureSubmission.
  </verify>
  <done>
    Zod schema matches backend Participants fields with French error messages. API client has functions for all 3 submission steps. TanStack Query mutation orchestrates the full create-participant -> upload-media -> create-signature flow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build signing page with form, signature canvas, and success confirmation</name>
  <files>
    frontend/src/pages/SignPage.tsx
    frontend/src/pages/SuccessPage.tsx
    frontend/src/components/ParticipantForm.tsx
    frontend/src/components/SignatureCanvas.tsx
    frontend/src/App.tsx
  </files>
  <action>
    **1. Create frontend/src/components/SignatureCanvas.tsx** -- Touch-enabled signature canvas:

    - Use react-signature-canvas with ref
    - Handle high-DPI displays: on mount, get canvas element, calculate DPI ratio via `window.devicePixelRatio`, set canvas.width and canvas.height to CSS dimensions * DPI ratio, then scale context
    - Add `touch-none` CSS class to prevent browser gestures during signing
    - Set white background color (`backgroundColor="rgb(255, 255, 255)"`)
    - Expose two methods via forwardRef/useImperativeHandle:
      - `isEmpty(): boolean` -- checks if canvas has been drawn on
      - `getBlob(): Promise<Blob | null>` -- converts trimmed canvas to PNG blob
      - `clear(): void` -- clears the canvas
    - Canvas container: `w-full` width, `h-48` height (192px, good for mobile signatures)
    - Add "Effacer" (Clear) button below the canvas, using shadcn Button component (variant="outline", size="sm")
    - Add a thin border and rounded corners around the canvas area
    - Add a subtle placeholder text "Signez ici" centered in the canvas area (disappears on first touch)

    CRITICAL iOS Safari considerations from research:
    - Lock canvas dimensions on mount (do NOT resize dynamically)
    - Use `touch-none` to prevent page scroll during drawing
    - Set canvas size via element attributes (not CSS width/height) to avoid blur

    **2. Create frontend/src/components/ParticipantForm.tsx** -- Complete form with all fields:

    - Use React Hook Form with zodResolver and the participantSchema from schemas.ts
    - All inputs must have `min-h-[44px]` for iOS touch targets
    - Single-column layout for mobile-first design
    - Fields in order:
      1. Nom (lastName) - text input, required
      2. Prenom (firstName) - text input, required
      3. Email - type="email" inputMode="email" autoComplete="email", required
      4. Ville (city) - text input, required
      5. Numero d'inscription professionnelle (professionalNumber) - type="text", optional, with helper text "Si applicable (veterinaires, pharmaciens)"
      6. Type de beneficiaire (beneficiaryType) - select dropdown with 7 options (French labels: ASV, Autre, Eleveur, Etudiant, Pharmacien, Technicien, Veterinaire)
      7. Preciser le type (beneficiaryTypeOther) - conditional text input, only shown when "Autre" is selected (use watch('beneficiaryType'))
      8. SignatureCanvas component (from above)
      9. Droit a l'image checkbox (consentRightToImage) - with label "J'autorise l'utilisation de photos prises lors de l'evenement"
      10. Submit button - full width, min-h-[44px], text "Signer", disabled during submission, shows "Envoi en cours..." when pending

    - Use shadcn/ui components: Input, Label, Select, Checkbox, Button, Card
    - Show validation errors below each field in red text
    - Show global error message if submission fails (mutation.error)

    Props: `onSubmit: (data: ParticipantFormData, signatureBlob: Blob) => void`, `isPending: boolean`, `error: Error | null`

    On form submit:
    1. Validate form via React Hook Form
    2. Check signature canvas is not empty (if empty, show error "La signature est requise")
    3. Get signature blob from canvas
    4. Call onSubmit with form data and blob

    **3. Create frontend/src/pages/SignPage.tsx** -- Main signing page:

    - Route parameter: `dayId` from React Router useParams
    - On mount: fetch attendance day info via `fetchAttendanceDay(dayId)` and sessions via `fetchSessionsByDay(dayId)`
    - Loading state: show spinner or "Chargement..." text
    - Error state: show "Journee introuvable" if day fetch fails
    - Session selection: If day has multiple sessions, show radio buttons or select to choose which session to sign for. If only one session, auto-select it. If no sessions exist, show error "Aucune session configuree pour cette journee"
    - Display event context at top: event title (from depth=1 attendance day response), date
    - Render ParticipantForm below event context
    - On form submit: call useSignatureSubmission mutation with formData, signatureBlob, selected sessionId
    - On mutation success: navigate to /success using React Router useNavigate, passing state: `{ participantName: formData.firstName }`

    Wrap the page in a max-w-lg mx-auto container for readable form width on larger screens. Add px-4 py-6 padding for mobile.

    **4. Create frontend/src/pages/SuccessPage.tsx** -- Confirmation page:

    - Display a success icon (CheckCircle from lucide-react, green, large)
    - Title: "Signature enregistree !"
    - Subtitle: "Merci, votre signature a ete enregistree avec succes."
    - If location.state.participantName exists, show "Merci {firstName} !"
    - No navigation back to form (prevent double submission)
    - Simple, clean, centered layout
    - Use shadcn Card component for the success message

    **5. Update frontend/src/App.tsx** -- Wire up real routes:

    - Replace placeholder routes with actual page components
    - Import SignPage and SuccessPage
    - Routes:
      - `/` -> simple landing page (keep existing placeholder or redirect)
      - `/sign/:dayId` -> SignPage
      - `/success` -> SuccessPage
    - Wrap Routes in QueryClientProvider from @tanstack/react-query (create QueryClient instance)
  </action>
  <verify>
    Run `cd /workspace/frontend && npx tsc --noEmit` to verify all components compile.
    Run `cd /workspace/frontend && npx vite build` to verify production build succeeds.
    Verify SignPage.tsx imports and uses useSignatureSubmission hook.
    Verify ParticipantForm.tsx uses all 7 beneficiary types.
    Verify SignatureCanvas.tsx handles devicePixelRatio.
    Verify App.tsx has QueryClientProvider and routes for /sign/:dayId and /success.
  </verify>
  <done>
    Complete signing flow built: SignPage loads day/session context, renders ParticipantForm with all required fields, SignatureCanvas handles touch input with DPI scaling, submission creates participant + uploads signature + creates signature record via 3-step API flow, SuccessPage shows confirmation. All components use shadcn/ui, mobile-first layout with 44px touch targets, French labels and error messages.
  </done>
</task>

</tasks>

<verification>
1. `cd /workspace/frontend && npx tsc --noEmit` passes
2. `cd /workspace/frontend && npx vite build` succeeds
3. /sign/:dayId route renders SignPage with form fields matching SIGN-03 requirements
4. Signature canvas uses react-signature-canvas with DPI handling (SIGN-04)
5. Form includes right-to-image consent checkbox (SIGN-06)
6. Submission flow: participant creation -> media upload -> signature creation (SIGN-05)
7. Success page shows confirmation message (SIGN-07)
8. All French labels: Nom, Prenom, Email, Ville, Type de beneficiaire, Signer
9. Zod validation with French error messages
10. Mobile-first: single column, min-h-[44px] inputs, touch-none canvas
</verification>

<success_criteria>
- SIGN-03: Form has all 6 required fields (lastName, firstName, email, city, registrationNumber, beneficiaryType)
- SIGN-04: Signature canvas renders, handles touch input, exports PNG blob
- SIGN-05: Signature uploads as image file via Media collection (not stored in client memory)
- SIGN-06: Right-to-image consent checkbox present and submitted
- SIGN-07: Success page shown after submission
- All components compile and build without errors
- Mobile-first layout with appropriate touch targets
</success_criteria>

<output>
After completion, create `.planning/phases/02-public-signature-flow/02-03-SUMMARY.md`
</output>
