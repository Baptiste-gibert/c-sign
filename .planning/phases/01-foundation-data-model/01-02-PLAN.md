---
phase: 01-foundation-data-model
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/collections/Events.ts
  - backend/src/collections/AttendanceDays.ts
  - backend/src/collections/Sessions.ts
  - backend/src/collections/Participants.ts
  - backend/src/collections/Signatures.ts
  - backend/src/hooks/events/afterChange.ts
  - backend/src/payload.config.ts
autonomous: true

must_haves:
  truths:
    - "Event collection accepts title, location, selectedDates array, expenseType, organizerName, organizerEmail, cnovDeclarationNumber"
    - "AttendanceDay records are auto-created via afterChange hook when Event dates are added"
    - "Existing AttendanceDays are never auto-deleted when dates are removed (orphaned days preserved)"
    - "Session collection allows organizer to define custom session names per AttendanceDay"
    - "Participant collection includes 7 beneficiary types in alphabetical order with French labels"
    - "Selecting 'Autre' as beneficiary type reveals a free text field"
    - "Signature record links a Participant to a Session with a Media image reference"
    - "One signature per participant per session is enforced"
  artifacts:
    - path: "backend/src/collections/Events.ts"
      provides: "Event collection with selectedDates array and expense type"
      contains: "selectedDates"
    - path: "backend/src/collections/AttendanceDays.ts"
      provides: "AttendanceDay collection linked to Event"
      contains: "attendance-days"
    - path: "backend/src/collections/Sessions.ts"
      provides: "Session collection linked to AttendanceDay"
      contains: "sessions"
    - path: "backend/src/collections/Participants.ts"
      provides: "Participant with beneficiary taxonomy"
      contains: "beneficiaryType"
    - path: "backend/src/collections/Signatures.ts"
      provides: "Signature linking participant + session + media"
      contains: "signatures"
    - path: "backend/src/hooks/events/afterChange.ts"
      provides: "Auto-generation of AttendanceDay records"
      contains: "afterChange"
  key_links:
    - from: "backend/src/collections/Events.ts"
      to: "backend/src/hooks/events/afterChange.ts"
      via: "hooks.afterChange array"
      pattern: "afterChange.*afterEventChange"
    - from: "backend/src/hooks/events/afterChange.ts"
      to: "backend/src/collections/AttendanceDays.ts"
      via: "payload.create for attendance-days"
      pattern: "collection.*attendance-days"
    - from: "backend/src/collections/Signatures.ts"
      to: "backend/src/collections/Sessions.ts"
      via: "relationship field to sessions"
      pattern: "relationTo.*sessions"
    - from: "backend/src/collections/Signatures.ts"
      to: "backend/src/collections/Participants.ts"
      via: "relationship field to participants"
      pattern: "relationTo.*participants"
    - from: "backend/src/payload.config.ts"
      to: "backend/src/collections/Events.ts"
      via: "collections array import"
      pattern: "import.*Events"
---

<objective>
Create all domain collections (Events, AttendanceDays, Sessions, Participants, Signatures) with the afterChange hook that auto-generates AttendanceDay records when event dates change.

Purpose: Implement the core data model that powers the entire c-sign application. The Event -> AttendanceDay -> Session hierarchy with per-session signatures is the central architectural decision. Getting this right in Phase 1 prevents cascading issues in Phases 2-4.
Output: Five domain collections registered in Payload, with the auto-generation hook working correctly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-model/01-CONTEXT.md
@.planning/phases/01-foundation-data-model/01-RESEARCH.md
@.planning/phases/01-foundation-data-model/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event, AttendanceDay, and Session collections with afterChange hook</name>
  <files>
    backend/src/collections/Events.ts
    backend/src/collections/AttendanceDays.ts
    backend/src/collections/Sessions.ts
    backend/src/hooks/events/afterChange.ts
  </files>
  <action>
    **Events.ts** — Parent collection per locked decisions:
    - `slug: 'events'`
    - `admin.useAsTitle: 'title'`, `admin.defaultColumns: ['title', 'location', 'expenseType', 'createdAt']`
    - Access: create requires authenticated user. read/update/delete use `organizerScoped` (import from `@/access/organizerScoped`).
    - Fields (use admin.group for logical grouping — Claude's discretion):
      - Group "Informations generales":
        - `title`: text, required
        - `location`: text, required, label 'Lieu'
        - `organizerName`: text, required, label 'Nom de l organisateur'
        - `organizerEmail`: email, required, label 'Email de l organisateur'
      - Group "Classification":
        - `expenseType`: select, required, label 'Type de depense', options (in French per locked decision):
          - { label: 'Hospitalite - Collation', value: 'hospitality_snack' }
          - { label: 'Hospitalite - Restauration', value: 'hospitality_catering' }
          - { label: 'Hospitalite - Hebergement', value: 'hospitality_accommodation' }
          - { label: 'Frais d inscription evenement', value: 'event_registration' }
          - { label: 'Frais de reunion/organisation', value: 'meeting_organization' }
          - { label: 'Frais de transport', value: 'transport' }
        - `cnovDeclarationNumber`: text, optional, label 'Numero de declaration CNOV'
      - Group "Dates":
        - `selectedDates`: array, required, minRows: 1, label 'Dates de l evenement', fields: [{ name: 'date', type: 'date', required: true, admin: { date: { pickerAppearance: 'dayOnly' } } }]
        - NOTE: This is an array-of-dates (not date range) per locked decision for non-consecutive days
      - Group "Relations" (readOnly in admin):
        - `attendanceDays`: relationship, relationTo: 'attendance-days', hasMany: true, admin: { readOnly: true, description: 'Genere automatiquement a partir des dates selectionnees' }
        - `createdBy`: relationship, relationTo: 'users', required: true, admin: { readOnly: true }
    - Hooks:
      - `beforeChange`: Set `createdBy` to current user ID on create operation (if not already set). Use `req.user.id`.
      - `afterChange`: Import and use `afterEventChange` from `@/hooks/events/afterChange`

    **afterChange.ts** — Auto-generate AttendanceDays:
    - Import `CollectionAfterChangeHook` from 'payload'
    - Logic:
      1. Skip if `req.context.preventLoop` is true (infinite loop prevention per research pitfall)
      2. Get `selectedDates` from `doc`
      3. Query existing AttendanceDays for this event: `req.payload.find({ collection: 'attendance-days', where: { event: { equals: doc.id } }, limit: 1000, req })`
      4. For each date in `selectedDates`, check if an AttendanceDay exists with that exact date
      5. If not, create one: `req.payload.create({ collection: 'attendance-days', data: { event: doc.id, date: dateObj.date }, req })`
      6. CRITICAL: Do NOT delete orphaned days (per locked decision). Orphaned days are preserved.
      7. After creating new days, update the Event's `attendanceDays` relationship field to include all AttendanceDay IDs (existing + new). Use `req.payload.update` with `context: { ...req.context, preventLoop: true }` to prevent infinite loop.
    - Return `doc`

    **AttendanceDays.ts:**
    - `slug: 'attendance-days'`
    - `admin.useAsTitle: 'date'`, `admin.defaultColumns: ['event', 'date']`
    - Access: read uses organizerScoped pattern (but filtering by parent event's createdBy). For simplicity in Phase 1, allow any authenticated user to read (we will tighten in Phase 3 when custom dashboard arrives). Create restricted to system (hooks create these). Update/delete: isAdmin only.
    - Fields:
      - `event`: relationship, relationTo: 'events', required: true
      - `date`: date, required, admin: { date: { pickerAppearance: 'dayOnly' } }
      - `sessions`: relationship, relationTo: 'sessions', hasMany: true, admin: { description: 'Sessions pour cette journee' }

    **Sessions.ts:**
    - `slug: 'sessions'`
    - `admin.useAsTitle: 'name'`, `admin.defaultColumns: ['name', 'attendanceDay']`
    - Access: create/read/update for authenticated users, delete for admins. (Sessions are created manually by organizer per locked decision.)
    - Fields:
      - `name`: text, required, label 'Nom de la session' (e.g., "Conference", "Dejeuner", "Atelier")
      - `attendanceDay`: relationship, relationTo: 'attendance-days', required: true
      - `signatures`: relationship, relationTo: 'signatures', hasMany: true, admin: { readOnly: true, description: 'Signatures pour cette session' }
  </action>
  <verify>
    1. `ls /workspace/backend/src/collections/Events.ts /workspace/backend/src/collections/AttendanceDays.ts /workspace/backend/src/collections/Sessions.ts` — all exist
    2. `ls /workspace/backend/src/hooks/events/afterChange.ts` — exists
    3. `grep "selectedDates" /workspace/backend/src/collections/Events.ts` — array field present
    4. `grep "preventLoop" /workspace/backend/src/hooks/events/afterChange.ts` — infinite loop protection present
    5. `grep -v "delete" /workspace/backend/src/hooks/events/afterChange.ts | grep -c "remove\|destroy"` — confirms no deletion logic (orphaned days preserved)
  </verify>
  <done>
    Event collection stores title, location, dates array, expense type, CNOV number, organizer info, and createdBy. afterChange hook creates AttendanceDays for new dates without removing existing ones. Session collection allows custom named sessions per AttendanceDay. All relationships correctly wired.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Participant and Signatures collections, register all collections in Payload config</name>
  <files>
    backend/src/collections/Participants.ts
    backend/src/collections/Signatures.ts
    backend/src/payload.config.ts
  </files>
  <action>
    **Participants.ts** — Per locked decisions:
    - `slug: 'participants'`
    - `admin.useAsTitle: 'lastName'`, `admin.defaultColumns: ['lastName', 'firstName', 'email', 'beneficiaryType']`
    - Access: create open (public participants will be created via signing flow in Phase 2 — for now, any authenticated user can create). Read for authenticated users. Update/delete for authenticated users.
    - Fields:
      - `lastName`: text, required, label 'Nom'
      - `firstName`: text, required, label 'Prenom'
      - `email`: email, required (NOT unique — same person can attend multiple events, and public form in Phase 2 creates records per submission)
      - `city`: text, required, label 'Ville'
      - `professionalNumber`: text, optional, label 'Numero d inscription professionnelle', admin: { description: 'Si applicable (veterinaires, pharmaciens)' }
      - `beneficiaryType`: select, required, label 'Type de beneficiaire', options in ALPHABETICAL order per locked decision:
        - { label: 'ASV', value: 'asv' }
        - { label: 'Autre', value: 'autre' }
        - { label: 'Eleveur', value: 'eleveur' }
        - { label: 'Etudiant', value: 'etudiant' }
        - { label: 'Pharmacien', value: 'pharmacien' }
        - { label: 'Technicien', value: 'technicien' }
        - { label: 'Veterinaire', value: 'veterinaire' }
      - `beneficiaryTypeOther`: text, optional, label 'Preciser le type', admin: { condition: (data) => data?.beneficiaryType === 'autre', description: 'Requis lorsque "Autre" est selectionne' }
      - NOTE: 7 types, French labels, alphabetical order — all per locked decision. "Autre" reveals free text field per locked decision.
      - NOTE: Conditional field is at TOP LEVEL (not inside array) to avoid Payload 3.x conditional-inside-array rendering bug per research pitfall.

    **Signatures.ts** — Per locked decisions (one signature per participant per session):
    - `slug: 'signatures'`
    - `admin.useAsTitle: 'id'`, `admin.defaultColumns: ['participant', 'session', 'createdAt']`
    - Access: create open (public signing flow in Phase 2 will create these). Read for authenticated users. Update/delete for admins.
    - Fields:
      - `participant`: relationship, relationTo: 'participants', required: true
      - `session`: relationship, relationTo: 'sessions', required: true
      - `image`: upload, relationTo: 'media', required: true (the actual signature image file)
      - `rightToImage`: checkbox, defaultValue: false, label 'Droit a l image', admin: { description: 'Autorise l utilisation de photos prises lors de l evenement' }
    - Unique constraint: Add a `beforeValidate` or `beforeChange` hook that checks if a signature already exists for the same participant + session combination. If duplicate found, throw a `ValidationError`. This enforces the locked decision: "One signature per participant per session."

    **Update payload.config.ts:**
    - Import ALL collections: Users, Media, Events, AttendanceDays, Sessions, Participants, Signatures
    - Register them in the `collections` array
    - Order: Users, Events, AttendanceDays, Sessions, Participants, Signatures, Media

    After updating config, verify TypeScript compilation: `cd /workspace/backend && npx tsc --noEmit 2>&1 | head -30`
  </action>
  <verify>
    1. `ls /workspace/backend/src/collections/Participants.ts /workspace/backend/src/collections/Signatures.ts` — both exist
    2. `grep "beneficiaryType" /workspace/backend/src/collections/Participants.ts` — beneficiary field present
    3. `grep "autre" /workspace/backend/src/collections/Participants.ts` — "autre" option present
    4. `grep "condition" /workspace/backend/src/collections/Participants.ts` — conditional reveal for beneficiaryTypeOther
    5. `grep "rightToImage" /workspace/backend/src/collections/Signatures.ts` — right-to-image checkbox present
    6. `grep -c "import" /workspace/backend/src/payload.config.ts` — at least 7 collection imports
    7. `cd /workspace/backend && npx tsc --noEmit 2>&1 | head -20` — no TypeScript errors
  </verify>
  <done>
    Participant collection has 7 beneficiary types (alphabetical, French labels) with conditional "Autre" free text field. Signatures collection links participant + session + media image with uniqueness enforcement. All 7 collections registered in payload.config.ts. TypeScript compiles successfully.
  </done>
</task>

</tasks>

<verification>
1. All 5 domain collection files exist under backend/src/collections/
2. afterChange hook exists at backend/src/hooks/events/afterChange.ts
3. payload.config.ts imports and registers all 7 collections (Users, Media, Events, AttendanceDays, Sessions, Participants, Signatures)
4. TypeScript compiles without errors
5. Event.selectedDates is an array field (not date range)
6. Beneficiary types are 7 options in alphabetical order with French labels
7. "Autre" conditional field is at top level, not inside an array
8. No deletion logic for orphaned AttendanceDays in the hook
9. Infinite loop prevention via req.context.preventLoop in afterChange hook
</verification>

<success_criteria>
- Event -> AttendanceDay -> Session hierarchy properly modeled with relationship fields
- afterChange hook auto-creates AttendanceDays for new dates, preserves orphaned ones
- Participant beneficiary taxonomy matches locked decision exactly (7 types, alphabetical, French)
- Signature uniqueness per participant+session enforced
- All collections registered in Payload config, TypeScript passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-model/01-02-SUMMARY.md`
</output>
