---
phase: 08-security-access
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/lib/security/tokens.ts
  - backend/src/collections/Events.ts
  - backend/src/app/(payload)/api/qr-code/route.ts
autonomous: true

must_haves:
  truths:
    - "Events have a unique, unguessable signingToken field generated on creation"
    - "QR code generation uses signingToken instead of dayId"
    - "Token is cryptographically secure (nanoid, ~126 bits entropy)"
  artifacts:
    - path: "backend/src/lib/security/tokens.ts"
      provides: "Token generation utility"
      exports: ["generateSigningToken"]
    - path: "backend/src/collections/Events.ts"
      provides: "signingToken field with auto-generation hook"
      contains: "signingToken"
    - path: "backend/src/app/(payload)/api/qr-code/route.ts"
      provides: "QR code endpoint using signingToken"
      contains: "signingToken"
  key_links:
    - from: "backend/src/lib/security/tokens.ts"
      to: "backend/src/collections/Events.ts"
      via: "beforeChange hook generates token on create"
      pattern: "generateSigningToken"
    - from: "backend/src/collections/Events.ts"
      to: "backend/src/app/(payload)/api/qr-code/route.ts"
      via: "QR route looks up event by signingToken"
      pattern: "signingToken"
---

<objective>
Add unguessable signing tokens to Events and update QR code generation to use tokens instead of sequential IDs.

Purpose: Prevent brute-force URL enumeration of signing pages. Currently `/sign/5` exposes sequential IDs — attackers can iterate and access any event's signing page. Tokens like `/sign/a7f3b2c9...` are cryptographically unguessable.
Output: Token generation utility, Events collection with signingToken field, QR code endpoint using tokens
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-security-access/08-RESEARCH.md
@backend/src/collections/Events.ts
@backend/src/app/(payload)/api/qr-code/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Token generation utility and Events signingToken field</name>
  <files>backend/src/lib/security/tokens.ts, backend/src/collections/Events.ts</files>
  <action>
1. Install nanoid:
   ```bash
   cd /workspace/backend && npm install nanoid
   ```
   Note: nanoid v5+ is ESM-only. If import issues arise in the Next.js server environment, use `import { nanoid } from 'nanoid'` (named export). If that fails, try `import { customAlphabet } from 'nanoid'` or fall back to `crypto.randomBytes(16).toString('hex')` from Node.js built-in crypto.

2. Create `backend/src/lib/security/tokens.ts`:
   - Export `generateSigningToken(): string` — returns a 21-character nanoid (default alphabet: A-Za-z0-9_-, ~126 bits entropy)
   - If nanoid ESM import fails, use Node.js crypto fallback:
     ```typescript
     import { randomBytes } from 'crypto'
     export function generateSigningToken(): string {
       return randomBytes(16).toString('base64url') // 22 chars, ~128 bits entropy, URL-safe
     }
     ```

3. Update `backend/src/collections/Events.ts`:
   - Import `generateSigningToken` from `@/lib/security/tokens`
   - Add a new field `signingToken` in the "Informations generales" tab:
     ```typescript
     {
       name: 'signingToken',
       type: 'text',
       unique: true,
       index: true,
       admin: {
         readOnly: true,
         description: 'Jeton de signature unique pour les URLs publiques (genere automatiquement)',
       },
     }
     ```
   - Add a `beforeChange` hook (BEFORE the existing status validation hook) that generates the token on create:
     ```typescript
     ({ data, operation }) => {
       if (operation === 'create' && !data.signingToken) {
         data.signingToken = generateSigningToken()
       }
       return data
     }
     ```
   - Add a custom API endpoint or hook for token regeneration: Create a new inline hook or a separate route. For simplicity, add a field `regenerateToken` (type: checkbox, virtual/admin-only) that triggers token regeneration on update:
     ```typescript
     // In beforeChange hooks:
     ({ data, operation }) => {
       if (operation === 'update' && data.regenerateToken) {
         data.signingToken = generateSigningToken()
         delete data.regenerateToken // Don't persist the flag
       }
       return data
     }
     ```
     ALTERNATIVELY (simpler and more explicit): Create a dedicated API route for token regeneration at `backend/src/app/(payload)/api/events/[id]/regenerate-token/route.ts`. This is cleaner because it's an explicit action, not a side effect of a checkbox field. Choose whichever approach is simpler.

     The PREFERRED approach is a dedicated API route:
     ```typescript
     // POST /api/events/[id]/regenerate-token
     // Requires auth (organizer who owns the event)
     // Generates new signingToken and saves
     ```

   - Keep ALL existing fields, hooks, and access control unchanged.
  </action>
  <verify>
- Token utility exists: `ls backend/src/lib/security/tokens.ts`
- Events has signingToken field: `grep -n "signingToken" backend/src/collections/Events.ts`
- Token generation on create: `grep -n "generateSigningToken" backend/src/collections/Events.ts`
- nanoid or crypto import: `grep -n "nanoid\|randomBytes" backend/src/lib/security/tokens.ts`
- TypeScript compiles: `cd /workspace/backend && npx tsc --noEmit --pretty 2>&1 | head -50`
  </verify>
  <done>Events collection has unique signingToken field auto-generated on creation, with regeneration capability via API route or hook</done>
</task>

<task type="auto">
  <name>Task 2: Update QR code route to use signingToken</name>
  <files>backend/src/app/(payload)/api/qr-code/route.ts</files>
  <action>
1. Update `backend/src/app/(payload)/api/qr-code/route.ts`:
   - Change the endpoint to accept `eventId` (or keep `dayId` for backward compatibility during transition) AND look up the event's `signingToken`
   - The current flow: QR code encodes `/sign/{dayId}`. The NEW flow: QR code encodes `/sign/{signingToken}`
   - Implementation:
     a. Accept `eventId` query parameter (the organizer UI will pass the event ID)
     b. Import `getPayload` from `payload` to query the database
     c. Look up the event by ID to get its `signingToken`:
        ```typescript
        import { getPayload } from 'payload'
        import configPromise from '@payload-config'

        const payload = await getPayload({ config: configPromise })
        const event = await payload.findByID({
          collection: 'events',
          id: eventId,
          depth: 0,
        })
        ```
     d. If event has no signingToken, return 400 error
     e. Generate QR code URL as: `${baseUrl}/sign/${event.signingToken}`
     f. Also support `dayId` parameter for backward compatibility: if `dayId` is provided, look up the day's event, then get the signingToken. Include the dayId in the URL as a query param: `/sign/${signingToken}?day=${dayId}`

   - Return `{ qrDataUrl, signUrl, signingToken }` in the response

   IMPORTANT: The current QR code URL includes dayId because the signing page loads data by day. With the token system, the signing page will need to look up the event by token, then find its attendance days. The URL format should be `/sign/{signingToken}` (Plan 05 will handle the frontend route migration). For now, include `dayId` as a query parameter so the existing signing page can still work: `/sign/{signingToken}?day={dayId}` — but the primary identifier is the token.

   IMPORTANT: Keep the existing `dayId`-only path working for backward compatibility during migration. If only `dayId` is provided (no eventId), generate a legacy URL. This ensures no breakage before Plan 05 completes the frontend migration.
  </action>
  <verify>
- QR route uses signingToken: `grep -n "signingToken" backend/src/app/(payload)/api/qr-code/route.ts`
- Payload query present: `grep -n "getPayload\|findByID" backend/src/app/(payload)/api/qr-code/route.ts`
- TypeScript compiles: `cd /workspace/backend && npx tsc --noEmit --pretty 2>&1 | head -50`
  </verify>
  <done>QR code generation creates URLs using signingToken instead of sequential dayId, with backward compatibility for existing flow</done>
</task>

</tasks>

<verification>
- `cd /workspace/backend && npx tsc --noEmit` passes without errors
- Events collection has signingToken field (unique, indexed)
- Token auto-generated on event creation
- Token regeneration available via API route or hook
- QR code endpoint generates URLs with signingToken
- nanoid (or crypto fallback) used for secure random generation
</verification>

<success_criteria>
- Every new event gets a unique, cryptographically secure signing token
- QR codes encode URLs with tokens (not sequential IDs)
- Token regeneration capability exists for compromised links
- Backward compatibility maintained during migration
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-access/08-04-SUMMARY.md`
</output>
