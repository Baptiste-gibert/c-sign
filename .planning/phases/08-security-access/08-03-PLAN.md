---
phase: 08-security-access
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/middleware.ts
  - backend/src/lib/api-fetch.ts
  - backend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "All responses include security headers (CSP, HSTS, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy)"
    - "CSRF protection is active on state-changing requests (POST/PUT/DELETE)"
    - "Public API calls from the signing page include CSRF tokens"
    - "Organizer API calls include CSRF tokens on mutations"
  artifacts:
    - path: "backend/src/middleware.ts"
      provides: "Security headers and CSRF protection middleware"
      contains: "Content-Security-Policy"
    - path: "backend/src/lib/api-fetch.ts"
      provides: "CSRF token injection for organizer API calls"
      contains: "csrf"
    - path: "backend/src/lib/api.ts"
      provides: "CSRF token injection for public API calls"
      contains: "csrf"
  key_links:
    - from: "backend/src/middleware.ts"
      to: "All HTTP responses"
      via: "Next.js middleware chain"
      pattern: "Content-Security-Policy"
    - from: "backend/src/lib/api-fetch.ts"
      to: "backend/src/middleware.ts"
      via: "CSRF token in request header validated by middleware"
      pattern: "csrf"
    - from: "backend/src/lib/api.ts"
      to: "backend/src/middleware.ts"
      via: "CSRF token in request header validated by middleware"
      pattern: "csrf"
---

<objective>
Add HTTP security headers middleware and CSRF protection for all API endpoints.

Purpose: Defend against clickjacking (X-Frame-Options), MIME sniffing (X-Content-Type-Options), XSS (CSP), protocol downgrade (HSTS), and cross-site request forgery (CSRF tokens). CORS handled by Next.js default same-origin policy (no custom headers needed per user decision).
Output: Next.js middleware with security headers and CSRF protection, updated API fetch utilities with CSRF token injection
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-security-access/08-RESEARCH.md
@backend/src/lib/api-fetch.ts
@backend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security headers and CSRF middleware</name>
  <files>backend/src/middleware.ts</files>
  <action>
1. Install CSRF package:
   ```bash
   cd /workspace/backend && npm install @edge-csrf/nextjs
   ```

2. Create `backend/src/middleware.ts` (Next.js middleware file):

   a. **CSRF protection** using @edge-csrf/nextjs:
      ```typescript
      import { createCsrfProtect } from '@edge-csrf/nextjs'
      import { NextResponse } from 'next/server'
      import type { NextRequest } from 'next/server'

      const csrfProtect = createCsrfProtect({
        cookie: {
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          name: '_csrf',
        },
      })
      ```
      - Call `csrfProtect(request, response)` in the middleware function
      - If CSRF validation fails on POST/PUT/DELETE, return 403 with JSON error body
      - Exclude Payload admin routes from CSRF check: paths starting with `/admin` or `/api/users` (Payload's own auth endpoints handle CSRF differently). Use the middleware `config.matcher` to control scope, OR check `request.nextUrl.pathname` in the handler.

   b. **Security headers** — add to every response:
      - `Content-Security-Policy`: Use a permissive policy that works with both Payload admin and the frontend:
        ```
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://challenges.cloudflare.com;
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: blob: *.public.blob.vercel-storage.com;
        font-src 'self' data:;
        connect-src 'self' https://challenges.cloudflare.com;
        frame-src https://challenges.cloudflare.com;
        frame-ancestors 'none';
        ```
        Note: `unsafe-inline` and `unsafe-eval` are needed for Payload admin and Tailwind. `challenges.cloudflare.com` is for future Turnstile CAPTCHA (Plan 06).
      - `Strict-Transport-Security`: `max-age=63072000; includeSubDomains; preload` (only in production — HSTS can lock out HTTP dev)
      - `X-Frame-Options`: `DENY`
      - `X-Content-Type-Options`: `nosniff`
      - `Referrer-Policy`: `strict-origin-when-cross-origin`
      - `Permissions-Policy`: `camera=(), microphone=(), geolocation=(), interest-cohort=()`

   c. **Middleware config** — match all routes except static files:
      ```typescript
      export const config = {
        matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
      }
      ```

   IMPORTANT: The @edge-csrf/nextjs library works by setting a CSRF token cookie and validating a matching header or form field on state-changing requests. Read the library docs/README to understand the exact API for `createCsrfProtect`. The `csrfProtect` function signature may be `csrfProtect(request)` returning an error, or `csrfProtect(request, response)` modifying the response. Adapt accordingly.

   IMPORTANT: If @edge-csrf/nextjs is incompatible with the current Next.js 15 / Edge runtime setup, fall back to a manual double-submit cookie pattern:
   - On GET requests: generate a random token, set it as a cookie `_csrf` (httpOnly: false so JS can read it)
   - On POST/PUT/DELETE: read `X-CSRF-Token` header and compare with `_csrf` cookie value
   - This is a valid CSRF defense (double-submit cookie pattern) and avoids library dependency issues.
  </action>
  <verify>
- File exists: `ls backend/src/middleware.ts`
- Contains security headers: `grep -n "Content-Security-Policy\|X-Frame-Options\|Strict-Transport" backend/src/middleware.ts`
- Contains CSRF setup: `grep -n "csrf\|CSRF" backend/src/middleware.ts`
- Package installed: `grep "@edge-csrf" backend/package.json`
- TypeScript compiles: `cd /workspace/backend && npx tsc --noEmit --pretty 2>&1 | head -50`
  </verify>
  <done>Next.js middleware sets security headers on all responses and validates CSRF tokens on state-changing requests</done>
</task>

<task type="auto">
  <name>Task 2: CSRF token injection in API fetch utilities</name>
  <files>backend/src/lib/api-fetch.ts, backend/src/lib/api.ts</files>
  <action>
1. Update `backend/src/lib/api-fetch.ts` (organizer API calls):
   - Add a helper function `getCsrfToken(): string | null` that reads the CSRF token from the cookie. The @edge-csrf/nextjs library stores the token in a cookie that JavaScript can read (the cookie name is `_csrf` or whatever was configured in Task 1).
     ```typescript
     function getCsrfToken(): string | null {
       if (typeof document === 'undefined') return null
       const match = document.cookie.match(/(?:^|;\s*)_csrf=([^;]+)/)
       return match ? decodeURIComponent(match[1]) : null
     }
     ```
   - Update `apiFetch` to inject `X-CSRF-Token` header on POST/PUT/DELETE/PATCH requests:
     ```typescript
     export async function apiFetch(url: string, init?: RequestInit): Promise<Response> {
       const headers = new Headers(init?.headers)
       const method = (init?.method || 'GET').toUpperCase()

       if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
         const csrfToken = getCsrfToken()
         if (csrfToken) {
           headers.set('X-CSRF-Token', csrfToken)
         }
       }

       const res = await fetch(url, { credentials: 'include', ...init, headers })
       if (!res.ok) {
         throw new ApiError(`${res.status} ${res.statusText}`, res.status)
       }
       return res
     }
     ```
   - Keep the `ApiError` class unchanged.

2. Update `backend/src/lib/api.ts` (public signing API calls):
   - Add the same `getCsrfToken()` helper (or extract to a shared utility if cleaner)
   - Update `createParticipant`, `uploadSignatureImage`, and `createSignature` to include `X-CSRF-Token` header:
     ```typescript
     const csrfToken = getCsrfToken()
     const headers: Record<string, string> = { 'Content-Type': 'application/json' }
     if (csrfToken) headers['X-CSRF-Token'] = csrfToken
     ```
   - For `uploadSignatureImage` (FormData upload): do NOT set Content-Type (browser sets multipart boundary), but DO add `X-CSRF-Token` header.
   - Keep all existing function signatures and error handling unchanged.

IMPORTANT: Extract `getCsrfToken` to a small shared file (e.g., `backend/src/lib/security/csrf-client.ts`) to avoid duplication between api-fetch.ts and api.ts. Import from there in both files.
  </action>
  <verify>
- Both files updated: `grep -n "CSRF\|csrf" backend/src/lib/api-fetch.ts backend/src/lib/api.ts`
- CSRF helper exists: `grep -rn "getCsrfToken" backend/src/lib/`
- TypeScript compiles: `cd /workspace/backend && npx tsc --noEmit --pretty 2>&1 | head -50`
  </verify>
  <done>All API calls (organizer and public) include CSRF tokens on state-changing requests. Middleware validates tokens server-side.</done>
</task>

</tasks>

<verification>
- `cd /workspace/backend && npx tsc --noEmit` passes without errors
- middleware.ts sets CSP, HSTS, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy
- middleware.ts validates CSRF tokens on POST/PUT/DELETE
- api-fetch.ts injects X-CSRF-Token on mutations
- api.ts injects X-CSRF-Token on public API mutations (createParticipant, uploadSignatureImage, createSignature)
</verification>

<success_criteria>
- Security headers present on all HTTP responses
- CSRF protection active on state-changing requests
- Both organizer and public API calls include CSRF tokens
- Payload admin routes excluded from CSRF validation (they use their own auth)
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-access/08-03-SUMMARY.md`
</output>
