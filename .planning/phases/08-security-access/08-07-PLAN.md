---
phase: 08-security-access
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/collections/Signatures.ts
  - backend/src/collections/Participants.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "CAPTCHA tokens sent by the client are verified server-side before signature creation"
    - "Direct POST to /api/signatures without a valid CAPTCHA token is rejected when rate limit requires CAPTCHA"
    - "Signature creation still works when CAPTCHA is not required (normal traffic below threshold)"
    - "Participant creation also verifies CAPTCHA token when present"
  artifacts:
    - path: "backend/src/collections/Signatures.ts"
      provides: "Server-side CAPTCHA verification in beforeChange hook"
      contains: "verifyTurnstileToken"
    - path: "backend/src/collections/Participants.ts"
      provides: "Server-side CAPTCHA verification in beforeChange hook"
      contains: "verifyTurnstileToken"
  key_links:
    - from: "backend/src/lib/security/captcha.ts"
      to: "backend/src/collections/Signatures.ts"
      via: "import in beforeChange hook"
      pattern: "import.*verifyTurnstileToken.*captcha"
    - from: "backend/src/lib/security/captcha.ts"
      to: "backend/src/collections/Participants.ts"
      via: "import in beforeChange hook"
      pattern: "import.*verifyTurnstileToken.*captcha"
---

<objective>
Wire server-side CAPTCHA verification into Signatures and Participants collection hooks, closing the critical gap where verifyTurnstileToken() exists but is never called.

Purpose: Without server-side verification, attackers can bypass the CAPTCHA by sending direct POST requests to /api/signatures or /api/participants. The client-side CAPTCHA widget is pure UX friction with no enforcement. This plan connects the existing verifyTurnstileToken() function to the collection hooks that guard public document creation.

Output: Signatures.ts and Participants.ts beforeChange hooks verify X-Captcha-Token header server-side when present, rejecting creation if the token is invalid.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-security-access/08-VERIFICATION.md

# Key source files
@backend/src/lib/security/captcha.ts
@backend/src/lib/security/rateLimit.ts
@backend/src/collections/Signatures.ts
@backend/src/collections/Participants.ts
@backend/src/app/(payload)/api/signatures/check-rate/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-side CAPTCHA verification to Signatures beforeChange hook</name>
  <files>backend/src/collections/Signatures.ts</files>
  <action>
    Import verifyTurnstileToken from '@/lib/security/captcha' at the top of the file.

    Add a new beforeChange hook function (before the existing one, or extract as a named function) that runs on 'create' operations only:

    1. Extract the X-Captcha-Token header from req.headers using `req.headers.get('x-captcha-token')` — Payload 3.x req extends Web Request API.
    2. If a captcha token IS present in the header:
       - Call `await verifyTurnstileToken(token)` to verify it server-side with Cloudflare
       - If verification returns false, throw an Error with French message: 'Verification CAPTCHA echouee. Veuillez reessayer.'
       - If verification returns true, allow the request to continue
    3. If NO captcha token is present:
       - Allow the request through — this means rate limiting has not triggered CAPTCHA yet (normal traffic), OR the request is coming from an authenticated admin/organizer (internal)
       - The existing rate limiting in check-rate endpoint still protects against volume abuse

    The logic is: when the client-side rate limiter has triggered CAPTCHA and the user has completed it, the token is sent in the header. The server MUST verify that token is genuine. If an attacker skips the CAPTCHA widget and sends a request without the token, the rate limiting endpoint would have already told the client to show CAPTCHA — but since the attacker bypasses the client, they won't have a token. The key insight: if a token IS sent, it must be valid. If NO token is sent, the request is allowed through (rate limiting handles volume control separately).

    However, for stronger defense-in-depth: also check if X-Device-Fingerprint header is present. If a fingerprint is provided, call checkRateLimit(fingerprint) to see if this device SHOULD have been challenged. If shouldChallenge is true but NO captcha token was provided, reject with: 'Verification CAPTCHA requise. Veuillez completer le CAPTCHA.'

    Import checkRateLimit from '@/lib/security/rateLimit' for this check.

    This creates a tight loop: rate limiter says "challenge this device" → client shows CAPTCHA → client sends token → server verifies token. An attacker who bypasses the client will hit the server-side rate check which says "this device should be challenged" but no token is present → rejected.

    Place this hook as the FIRST beforeChange hook in the array (before event status check and uniqueness check) so invalid CAPTCHA is caught early.
  </action>
  <verify>
    1. `cd /workspace/backend && npx tsc --noEmit` — TypeScript compiles without errors
    2. Grep for 'verifyTurnstileToken' in Signatures.ts — function is imported and called
    3. Grep for 'checkRateLimit' in Signatures.ts — rate limit re-check is present
    4. Verify the hook only runs on 'create' operations (not update/delete)
  </verify>
  <done>
    Signatures.ts beforeChange hook verifies X-Captcha-Token server-side:
    - Token present + valid → allowed
    - Token present + invalid → rejected with French error
    - No token + device not rate-limited → allowed (normal traffic)
    - No token + device should be challenged → rejected with French error
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-side CAPTCHA verification to Participants beforeChange hook</name>
  <files>backend/src/collections/Participants.ts</files>
  <action>
    Apply the same CAPTCHA verification pattern to Participants.ts since participant creation is also a public endpoint (create: () => true) and the client sends X-Captcha-Token on createParticipant calls too.

    Import verifyTurnstileToken from '@/lib/security/captcha' and checkRateLimit from '@/lib/security/rateLimit'.

    Create a beforeChange hook function (named verifyCaptchaToken or similar, typed as CollectionBeforeChangeHook) that:

    1. Only runs on 'create' operations
    2. Skips verification if request comes from an authenticated user (req.user is truthy) — organizers/admins creating participants via dashboard should not be challenged
    3. Extracts X-Captcha-Token from req.headers.get('x-captcha-token')
    4. If token present: verify with verifyTurnstileToken(), reject if invalid
    5. If no token: check X-Device-Fingerprint header. If fingerprint present, call checkRateLimit(). If shouldChallenge is true but no captcha token, reject.
    6. Otherwise allow through

    Add this hook to the beforeChange array BEFORE the existing sanitizeParticipantInput hook. Order: CAPTCHA check → sanitize → (implicit Payload save).

    Use the same French error messages as Task 1 for consistency.
  </action>
  <verify>
    1. `cd /workspace/backend && npx tsc --noEmit` — TypeScript compiles without errors
    2. Grep for 'verifyTurnstileToken' in Participants.ts — function is imported and called
    3. Verify authenticated users (req.user) bypass CAPTCHA check
    4. Verify hook order: CAPTCHA verification runs before sanitization
  </verify>
  <done>
    Participants.ts beforeChange hook verifies X-Captcha-Token server-side with same logic as Signatures:
    - Authenticated users bypass check entirely
    - Public creation follows same token/fingerprint verification flow
    - Hook runs before sanitizeParticipantInput in the array
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd /workspace/backend && npx tsc --noEmit` passes
2. Import wiring: `grep -r 'verifyTurnstileToken' backend/src/collections/` shows imports in both Signatures.ts and Participants.ts
3. Import wiring: `grep -r 'verifyTurnstileToken' backend/src/` shows captcha.ts (definition) + Signatures.ts + Participants.ts (usage) — no longer orphaned
4. Rate limit re-check: `grep -r 'checkRateLimit' backend/src/collections/` shows server-side enforcement in collection hooks
5. Defense-in-depth: A direct POST to /api/signatures with a forged/missing CAPTCHA token AND a fingerprint that exceeds rate limits will be rejected
6. Normal traffic: Submissions below rate limit threshold (no fingerprint or low count) pass through without CAPTCHA requirement
7. Authenticated bypass: Organizers creating participants via dashboard are not challenged
</verification>

<success_criteria>
- verifyTurnstileToken() is imported and called in Signatures.ts and Participants.ts beforeChange hooks
- checkRateLimit() is used for server-side re-verification of whether CAPTCHA should have been required
- TypeScript compiles without errors
- The orphaned captcha.ts export is now wired to collection hooks (VERIFICATION.md gap closed)
- Truth 12 from phase goal ("Dynamic CAPTCHA triggers only on suspicious submission volume") is now fully verified end-to-end: client-side triggering + server-side enforcement
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-access/08-07-SUMMARY.md`
</output>
